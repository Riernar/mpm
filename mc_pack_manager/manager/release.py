"""
Release management module

Part of the Minecraft Pack Manager utility (mpm)
"""
# Standard library import
import json
import logging
from pathlib import Path, PurePath
import requests
import tempfile
from typing import Union
import zipfile

# Local import
from .. import manifest
from .. import network
from .. import _filelist
from ..manager import common

LOGGER = logging.getLogger("mpm.manager.release")

PathLike = Union[str, Path]


def curse(
    snapshot: PathLike,
    output_zip: PathLike,
    packmodes=None,
    force=False,
    mpm_filepath=None,
):
    """
    Creates a .zip of the same format as curse/twitch that can be used to do a fresh install
        of the pack. This will *not* contain mods, but creates a manifest that list them (same
        thing curse does)

    Arguments
        snapshot -- snapshot file generated by 'mpm snapshot'
        output_file -- path to the output file to produce
        packmodes -- list of packmodes to include into the created .zip. Defaults to everything
        force -- erase output_zip if it already exists
        mpm_filepath -- if provided, bundle this pack manager into the .zip, so that it is part of the pack.
            The argument must be the path to the "mpm.py" file
    """
    # File checks and opening
    snapshot = Path(snapshot)
    output_zip = Path(output_zip)
    if not snapshot.is_file() or not zipfile.is_zipfile(snapshot):
        zipfile.BadZipFile("%s is not a zip file", snapshot)

    with tempfile.TemporaryDirectory(dir=".") as pack_dir:
        pack_dir = Path(pack_dir)
        with zipfile.ZipFile(snapshot) as zf:
            LOGGER.info("Decompressing snapshot in %s", pack_dir)
            zf.extractall(pack_dir)

        common.check_snapshot_dir(pack_dir)
        # Read manifest
        pack_manifest = manifest.pack.read_from(pack_dir)
        curse_manifest = manifest.curse.read(pack_dir / "manifest.json")
        # Check packmodes
        if packmodes:
            manifest.pack.check_packmodes(pack_manifest["packmodes"], packmodes)
        # Open zip archive
        LOGGER.info("Creating output .zip file")
        archive = zipfile.ZipFile(
            output_zip,
            mode="w" if force else "x",
            compression=zipfile.ZIP_DEFLATED,
            compresslevel=6,
        )
        # Compute mods
        if not packmodes:
            LOGGER.info("No 'packmodes' argument, using all packmodes")
            selected_mods = pack_manifest["mods"]
        else:
            selected_mods = manifest.pack.get_selected_mods(pack_manifest, packmodes)
        LOGGER.debug(
            "Selected mods:\n%s", common.format_modlist(selected_mods, print_version=True)
        )
        # Create new manifest
        LOGGER.info("Generating new manifest with selected mods")
        curse_manifest["files"] = [
            {"projectID": mod["addonID"], "fileID": mod["fileID"], "required": True}
            for mod in selected_mods
        ]
        curse_manifest["version"] = str(pack_manifest["pack-version"])
        curse_manifest["overrides"] = "overrides"
        with archive.open("manifest.json", mode="w") as f:
            f.write(json.dumps(curse_manifest, indent=4).encode("utf-8"))
        # Compute overrides
        if not packmodes:
            LOGGER.info("No 'packmodes' argument, using all overrides")
            selected_overrides = pack_manifest["override-cache"]
        else:
            selected_overrides = manifest.pack.get_selected_overrides(
                pack_manifest, packmodes
            )
        LOGGER.debug(
            "Selected overrides:\n  - %s", "\n  - ".join(selected_overrides.keys()),
        )
        # Compress overrides
        LOGGER.info("Adding selected overrides to .zip archive")
        for filepath in selected_overrides.keys():
            path = pack_dir / "overrides" / filepath
            archive.write(filename=path, arcname=path.relative_to(pack_dir))
        # Includes extra files (e.g. modlist)
        LOGGER.info("Adding extra modpack files to .zip archives")
        for extra in pack_dir.glob("*"):
            if extra.is_file() and extra.name not in (
                "manifest.json",
                "pack-manifest.json",
            ):
                archive.write(filename=extra, arcname=extra.relative_to(pack_dir))
            elif extra.is_dir() and extra.stem != "overrides":
                for sub_extra in extra.rglob("*"):
                    archive.write(
                        filename=sub_extra, arcname=sub_extra.relative_to(pack_dir)
                    )
        ## Include MPM
        if mpm_filepath is not None:
            LOGGER.info("Adding mpm to .zip archive")
            mpm_filepath = Path(mpm_filepath)
            arcname_root = PurePath("overrides/mpm")
            LOGGER.debug("Adding pack-manifest.json")
            new_manifest = manifest.pack.copy(
                pack_manifest,
                current_packmodes=list(packmodes) if packmodes else list(pack_manifest["packmodes"].keys())
            )
            with archive.open("overrides/pack-manifest.json", mode="w") as fp:
                manifest.pack.dump(new_manifest, fp)
            LOGGER.debug("Adding %s", mpm_filepath.name)
            archive.write(filename=mpm_filepath, arcname=arcname_root / mpm_filepath.name)
            LOGGER.debug("Adding %s", "requirements.txt")
            archive.write(
                filename=mpm_filepath.parent / "requirements.txt",
                arcname=arcname_root / "requirements.txt",
            )
            for source_file in _filelist.MPM_SRC_FILES:
                LOGGER.debug("Adding %s", source_file.relative_to(mpm_filepath.parent))
                archive.write(
                    filename=source_file,
                    arcname=arcname_root / source_file.relative_to(mpm_filepath.parent),
                )
        archive.close()
        LOGGER.debug("Cleaning up temporary dir")
    LOGGER.info("Done !")


def serverfiles(
    snapshot: PathLike,
    output_zip: PathLike,
    packmodes=None,
    force=False,
    mpm_filepath=None,
):
    """
    Creates a .zip that readily contains mods and everything else for the pack. Useful to make
        server files for instance.
    WARNING: be mindful of mods licenses before redistributing this zip !
    
    Arguments
        snapshot -- snapshot file generated by 'mpm snapshot'
        output_zip -- path to the output file to produce
        packmodes -- list of packmodes to include into the created .zip. Can be "ALL" to include them all
        force -- erase output_zip if it already exists
        mpm_filepath -- if provided, bundle this pack manager into the .zip, so that it is part of the pack.
            The argument must be the path to the "mpm.py" file
    """
    # File checks and opening
    output_zip = Path(output_zip)
    with tempfile.TemporaryDirectory(dir=".") as pack_dir:
        pack_dir = Path(pack_dir)
        with zipfile.ZipFile(snapshot) as zf:
            LOGGER.info("Decompressing snapshot in %s", pack_dir)
            zf.extractall(pack_dir)
        common.check_snapshot_dir(pack_dir)
        # Read manifest
        pack_manifest = manifest.pack.read_from(pack_dir)
        # Check packmodes
        if packmodes:
            manifest.pack.check_packmodes(pack_manifest["packmodes"], packmodes)
        else:
            LOGGER.info("No 'packmodes' argument, defaulting to 'server'")
            packmodes = {"server"}
        # Open zip archive
        LOGGER.info("Opening .zip file")
        archive = zipfile.ZipFile(
            output_zip,
            mode="w" if force else "x",
            compression=zipfile.ZIP_DEFLATED,
            compresslevel=6,
        )
        # Compute mods
        selected_mods = manifest.pack.get_selected_mods(pack_manifest, packmodes)
        LOGGER.debug(
            "Selected mods:\n%s", common.format_modlist(selected_mods, print_version=True)
        )
        LOGGER.info("Downloading %s mods to zip archive. This will take a while !", len(selected_mods))
        mod_dir = PurePath("mods/")
        for mod in selected_mods:
            addonID, fileID = mod["addonID"], mod["fileID"]
            LOGGER.info("  - %s", mod.get("name", f"{addonID}/{fileID}"))
            if "filename" in mod:
                jarname = mod["filename"]
            else:
                jarname = network.TwitchAPI.get_file_info(addonID, fileID)["fileName"]
            archive.writestr(
                str(mod_dir / jarname),
                requests.get(network.TwitchAPI.get_download_url(addonID, fileID)).content,
            )
        # Compute overrides
        selected_overrides = manifest.pack.get_selected_overrides(pack_manifest, packmodes)
        LOGGER.debug(
            "Selected overrides:\n  - %s", "\n  - ".join(selected_overrides.keys()),
        )
        # Compress overrides
        LOGGER.info("Adding selected overrides to zip archive")
        for filepath in selected_overrides.keys():
            path = pack_dir / "overrides" / filepath
            archive.write(filename=path, arcname=filepath)
        ## Include MPM
        if mpm_filepath is not None:
            LOGGER.info("Adding mpm to zip archive")
            mpm_filepath = Path(mpm_filepath)
            arcname_root = PurePath("mpm")
            LOGGER.debug("Adding pack-manifest.json")
            new_manifest = manifest.pack.copy(
                pack_manifest,
                current_packmodes=list(packmodes) if packmodes else list(pack_manifest["packmodes"].keys())
            )
            with archive.open("pack-manifest.json", mode="w") as fp:
                manifest.pack.dump(new_manifest, fp)
            LOGGER.debug("Adding %s", mpm_filepath.name)
            archive.write(filename=mpm_filepath, arcname=arcname_root / mpm_filepath.name)
            LOGGER.debug("Adding %s", "requirements.txt")
            archive.write(
                filename=mpm_filepath.parent / "requirements.txt",
                arcname=arcname_root / "requirements.txt",
            )
            for source_file in _filelist.MPM_SRC_FILES:
                LOGGER.debug("Adding %s", source_file.relative_to(mpm_filepath.parent))
                archive.write(
                    filename=source_file,
                    arcname=arcname_root / source_file.relative_to(mpm_filepath.parent),
                )
        archive.close()
        LOGGER.debug("Cleaning up temporary dir")
    LOGGER.info("Done !")
    print("\n\nThe generated zip contains the mods' jar files. Please, be mindful of mods licenses before distributing it !")
